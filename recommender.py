# -*- coding: utf-8 -*-
"""recommender.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yvrWiZV2D-KJ7EqVAPrlqaIGTmRXEgzY
"""

import os
import pandas as pd
import glob
import re
from nltk.corpus import stopwords
import nltk
from sklearn.preprocessing import LabelEncoder
import tensorflow as tf
from tensorflow.keras.models import Model
from tensorflow.keras.layers import Input, Embedding, Flatten, Concatenate, Dense
from sklearn.model_selection import train_test_split
import numpy as np
from datetime import datetime, timedelta

#load yelp_dataset
businesses = pd.read_json("/content/drive/MyDrive/yelp_academic_dataset_business.json", lines=True, orient='columns', chunksize=100000)
for business in businesses:
    data_business = business
    break

checkins = pd.read_json("/content/drive/MyDrive/yelp_academic_dataset_checkin.json", lines=True, orient='columns', chunksize=100000)
for checkin in checkins:
    data_checkin = checkin
    break

tips = pd.read_json("/content/drive/MyDrive/yelp_academic_dataset_tip.json", lines=True, orient='columns', chunksize=100000)
for tip in tips:
    data_tip = tip
    break

reviews = pd.read_json("/content/drive/MyDrive/yelp_academic_dataset_review.json", lines=True, orient='columns', chunksize=100000)
for review in reviews:
    data_review = review
    break

#Data Preparation
nltk.download('stopwords')
stop_words = list(set(stopwords.words('english')))
ch=['chairs.','chairs','chair']
stop_words.extend(ch)
# seperate Beauty & Spas shops
beauty_df = data_business[data_business['categories'].str.contains('Beauty & Spas', case=False, na=False)]
beauty_df.dropna()

beauty_review = data_review[data_review['business_id'].isin(beauty_df['business_id'])]

# remove stop words
beauty_review['text']=beauty_review['text'].apply(lambda x: x.lower())
beauty_review['text']=beauty_review['text'].apply(lambda x: ' '.join([word for word in x.split() if word not in (stop_words)]))

# create service_type column
sel=['nail','neck shaves','massage','pedicure','nail spa','spa','haircut','polish','shave','beard trims',
   'hair color','facial','hair extensions','skin','waxing','eyelash','tanning','eyebrow','hairstyle' ]
beauty_review["service_type"] = None
for i in sel:
    beauty_review["service_type"][beauty_review["text"].str.contains(i)] = i

beauty_review = beauty_review.dropna()
new_beauty_review = beauty_review[['user_id','business_id','stars','service_type','date']]

# Encode categorical data
user_encoder = LabelEncoder()
business_encoder = LabelEncoder()
new_beauty_review['user_id_encoded'] = user_encoder.fit_transform(new_beauty_review['user_id'])
new_beauty_review['business_id_encoded'] = business_encoder.fit_transform(new_beauty_review['business_id'])
num_users = len(user_encoder.classes_)
num_businesses = len(business_encoder.classes_)

#create model

def create_model(num_users, num_businesses, embedding_dim=5):
    user_input = Input(shape=(1,), name='user')
    business_input = Input(shape=(1,), name='business')
    print(user_input)
    user_embedding = Embedding(input_dim=num_users, output_dim=embedding_dim)(user_input)
    business_embedding = Embedding(input_dim=num_businesses, output_dim=embedding_dim)(business_input)

    user_flatten = Flatten()(user_embedding)
    business_flatten = Flatten()(business_embedding)

    concat = Concatenate()([user_flatten, business_flatten])
    dense1 = Dense(32, activation='relu')(concat)
    dense2 = Dense(16, activation='relu')(dense1)
    output = Dense(1, activation='sigmoid')(dense2)

    model = Model(inputs=[user_input, business_input], outputs=output)
    model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

    return model

model = create_model(num_users, num_businesses)
model.summary()

# Prepare data for training

X = [new_beauty_review['user_id_encoded'].values, new_beauty_review['business_id_encoded'].values]
y = (new_beauty_review['stars'] >= 4).astype(int).values  # Binary classification: high rating (4 or 5)

# Train the model
model.fit(X, y, epochs=10, batch_size=2, validation_split=0.2)

# create recommend func
def recommend(user_id, service_type, start_date, end_date, duration):
    # Get user index
    user_idx = user_encoder.transform([user_id])[0]

    # Get available businesses for the service type
    business_indices = new_beauty_review['business_id_encoded'].unique()
    business_indices = np.expand_dims(business_indices, axis=0)
    user_indices = np.full_like(business_indices, user_idx)

    # Predict scores for available businesses
    predictions = model.predict([user_indices.flatten(), business_indices.flatten()]).flatten()

    # Map predictions to businesses
    business_scores = {b_id: score for b_id, score in zip(business_indices.flatten(), predictions)}

    # Sort businesses by score
    sorted_businesses = sorted(business_scores.keys(), key=lambda b_id: business_scores[b_id], reverse=True)

    # Find available time slots within the preferred date range
    time_slots_recommendation = []
    time_slots_alternative = []
    for business_id in sorted_businesses:
        business_df = new_beauty_review[new_beauty_review['business_id_encoded'] == business_id]
        for index, row in business_df.iterrows():
            available_time = datetime.strptime(str(row['date']), '%Y-%m-%d %H:%M:%S')
            if (start_date.month,start_date.day) <= (available_time.month,available_time.day) <= (end_date.month,end_date.day) and row['service_type']==service_type:
                time_slots_recommendation.append({
                    'date':start_date.strftime('%Y') + available_time.strftime('-%m-%d'),
                    'time': available_time.strftime('%H:%M:%S'),
                    'confidenceScore': business_scores[business_id]
                })
            if (start_date.month,start_date.day) <= (available_time.month,available_time.day) <= (end_date.month,end_date.day) and row['service_type']!=service_type:
                time_slots_alternative.append({
                    'service_type':row['service_type'],
                    'date':start_date.strftime('%Y') + available_time.strftime('-%m-%d'),
                    'time': available_time.strftime('%H:%M:%S'),
                    'confidenceScore': business_scores[business_id]
                })

            if len(time_slots_recommendation) >= 2:
                break
        if len(time_slots_recommendation) >= 2:
            break
    return {
        'recommendedTimes': time_slots_recommendation,
        'alternativeServices': time_slots_alternative[0]
    }

# test sample

start_date = datetime(2024,6,1)
end_date = datetime(2024, 6,7)
recommendation = recommend('NDZvyYHTUWWu-kqgQzzDGQ', 'haircut', start_date, end_date, duration=30)
print(recommendation)

